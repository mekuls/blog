---
layout: post
title:  "Google App Engine Python Testing Setup"
date:   2015-06-22 00:20:00
categories: install testing python appengine
---

For me, getting into a feedback loop early on in a project is critical to the quality of the output. Here I describe the steps  that I took to quickly establish unit testing practices the first time I tried to program in python on the Google App Engine. 

I've been working on a project which is hosted on the Google App Engine. Most of the setup was straight forward but unit testing took a bit of additional effort to get working right.


Start with a virtualenv

{% highlight bash %}
$ virtualenv venv
$ source venv/bin/activate
{% endhighlight %}

For testing I'm using 

- The [Nose testing framework](https://nose.readthedocs.org/en/latest/)
- The [GAE Plugin for nose](https://github.com/Trii/NoseGAE)
- [WebTest](http://webtest.readthedocs.org/en/latest/) to cover the wsgi aspect of spinning things up.

{% highlight bash %}
$ pip install nose
$ pip install nosegae
$ pip install WebTest
{% endhighlight %}

In order to use the App Engine the SDK needs to be downloaded. I put mine in /opt/google_appengine and added an alias in my ~/.bashrc

[Here's a link to the python SDK](https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python)

{% highlight bash %}
export PATH=/opt/google_appengine:$PATH
{% endhighlight %}

I'm pretty sure that I've missed something so if you're reading this, take my instructions with a grain of salt. I'll try to remember to update this post if I find a better way.

With all of this in place we can then create a very basic app for proof of concept

app.yaml

{% highlight text %}

handlers:
- url: /static
  static_dir: static

- url: /.*
  script: myapp.app

libraries:
- name: webapp2
  version: latest
- name: jinja2
  version: latest
{% endhighlight %}


- Notice that the handlers are telling wsgi to send all requests to testapp.app
- Also notice the static handler, this is how we can easily send javascript and css content.

myapp.py

{% highlight python %}
import sys
import os
import urllib
import logging
import cgi
import jinja2
import webapp2


# setup the jinja environment
# here, we're setting up a templates folder at '/templates/
JINJA_ENVIRONMENT = jinja2.Environment(
    loader=jinja2.FileSystemLoader(os.path.dirname(__file__) + "/templates"),
    extensions=['jinja2.ext.autoescape'],
    autoescape=True)

# Here's a landing page
class LandingPage(webapp2.RequestHandler):
	def get(self):
		template = JINJA_ENVIRONMENT.get_template('landing.html')
		self.response.write(template.render())


app = webapp2.WSGIApplication([
    ('/', LandingPage),
], debug=True)

{% endhighlight %}


A very simple test case looks like this:

{% highlight python %}
from webtest import TestApp
import unittest
import myapp 


app = TestApp(myapp.app)

class LandingPageTest(unittest.TestCase):
   def test_200(self):
       # Build a request object passing the URI path to be tested.
       # You can also pass headers, query arguments etc.
       response = app.get('/')

       self.assertEqual(response.status_int, 200)

{% endhighlight %}


In a nutshell here we are

- Referencing TestApp from webtest so that we can do wsgi stuff
- Referencing myapp which is just myapp.py. We want to access the "app" variable which holds a WSGIApplication
- Simulating a url request
- Making assertions about the response.

To run tests, get into the working directory and run the following command. 

{% highlight bash %}
$ nosetests --with-gae --gae-lib-root=/opt/google_appengine
{% endhighlight %}

All up this took me a few hours to figure out. I'm hoping that the nosetests with GAE plugin holds well because apparently it includes with GAE testbed stuff which allows you to stub out ndb and a bunch of other stuff from the GAE libraries.
